/*
 * generated by Xtext 2.22.0
 */
package pt.isep.edom.i160826.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import pt.isep.edom.i160826.ucus.Actor
import pt.isep.edom.i160826.ucus.UseCase
import pt.isep.edom.i160826.ucus.Model

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class UcusDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		// Mandatory files
		fsa.generateFile("roles/Role.java", compileRole)
		fsa.generateFile("interactions/Interaction.java", compileInteraction)
		fsa.generateFile("factories/SFactory.java", compileSFactory)
		
		for (e: resource.allContents.toIterable.filter(Model)) {
			// Usually only one Model!!!
			fsa.generateFile("factories/Factory.java", e.compile)
			fsa.generateFile("factories/FactoryImpl.java", e.compileFactoryImpl)
			fsa.generateFile("model/ModelExecution.java", e.compileModel)
		}

		// Actors
		for (e : resource.allContents.toIterable.filter(Actor)){
			// The implementation class for each Actor
			fsa.generateFile("roles/" + e.name + ".java", e.compile)
		}
		
		// Use Cases
		for (e : resource.allContents.toIterable.filter(UseCase)){
			// The implementation class for each Actor
			fsa.generateFile("interactions/" + e.name + ".java", e.compile)
		}

	}
	
	def dispatch compile(Actor actor) {
		'''
		package roles;
		
		import interactions.Interaction;
		import factories.SFactory;
		
		public class «actor.name» implements Role {
			
			@Override
			public void execute() {
				boolean exit=false;

				java.util.Scanner in = new java.util.Scanner(System.in);

				while (!exit) {		
					System.out.println("# «actor.name» #");
					System.out.println("Please select option:");
			
					System.out.println("0- Exit");
					«var i = 1»	
					«FOR assoc : actor.association»
					System.out.println("«i»- «assoc.usecase.name» («assoc.usecase.subject.name»)");
					«{i = i + 1; null}»
					«ENDFOR»
					// Read an integer from the input
					int num = in.nextInt();

					switch (num) {
					case 0:
						exit=true;
						break;
					«{i = 1; null}»
					«FOR assoc : actor.association»
					case «i»:
						{
							Interaction inter=SFactory.getInstance().get«assoc.usecase.name»();
							inter.execute();
						}
						break;
						«{i = i + 1; null}»						
					«ENDFOR»
					}		
				}		
			}			
		}
		'''
	}	

	def dispatch compile(UseCase uc) {
		'''
		package interactions;
		
		import factories.*;
		
		public class «uc.name» implements Interaction {
			
			@Override
			public void execute() {
				
				System.out.println("«uc.name»: Please add behaviour code");
				
				«FOR inc : uc.includes»
				{
					// Calling included use case
					Interaction inter=SFactory.getInstance().get«inc.addition.name»();
					inter.execute();
				}
				«ENDFOR»				
			}			
		}
		'''
	}	
	
	def compileRole() {
		'''
		package roles;
		
		public interface Role {
			public void execute();
		}	
		'''
	}	
	
	def compileInteraction() {
		'''
		package interactions;
		
		public interface Interaction {
			public void execute();
		}

		'''
	}

	def compileSFactory() {
		'''
		package factories;
		
		public class SFactory {

		private static Factory factory=null;
		
			public static void setInstance(Factory f) {
				factory=f;
			}
			
			public static Factory getInstance() {
				if (factory==null) {
					factory=new FactoryImpl();
				}
				return factory;
			}
			
		}

		'''
	}
	
	def dispatch compile(Model model) {
		'''
		package factories; 

		import roles.*;
		import interactions.*;
				
		public interface Factory {
			
			«FOR actor : model.actor»
			public Role get«actor.name»();
			«ENDFOR»	
			«FOR sub : model.subject»			
			«FOR uc : sub.usecase»
			public Interaction get«uc.name»();
			«ENDFOR»
			«ENDFOR»
		}

		'''
	}			
	
	def compileFactoryImpl(Model model) {
		'''
		package factories; 

		import roles.*;
		import interactions.*;
				
		public class FactoryImpl implements Factory {
			
			«FOR actor : model.actor»
			public Role get«actor.name»() {
				return new «actor.name»();
				}
			«ENDFOR»	
			«FOR sub : model.subject»			
			«FOR uc : sub.usecase»
			public Interaction get«uc.name»() {
				return new «uc.name»();
				}
			«ENDFOR»
			«ENDFOR»
		}

		'''
	}	
	
	def compileModel(Model model) {
		'''
		package model;
		
		import roles.*;
		import factories.*;
				
		public class ModelExecution {
		
			public static void execute(Factory factory) {
				// Setup default factory
				SFactory.setInstance(factory);
		
				// Execute the roles...
				executeRoles();
			}
		
			private static void executeRoles() {
				boolean exit = false;
		
				java.util.Scanner in = new java.util.Scanner(System.in);
		
				while (!exit) {
					System.out.println("# Roles #");
					System.out.println("Please select option:");
		
					System.out.println("0- Exit");
					«var i = 1»	
					«FOR actor : model.actor»
					System.out.println("«i»- «actor.name»");
					«{i=i+1; null}»
					«ENDFOR»	
		
					// Read an integer from the input
					int num = in.nextInt();
		
					switch (num) {
						case 0:
							exit = true;
							break;
						«{i = 1; null}»	
						«FOR actor : model.actor»							
						case «i»: {
							Role role = SFactory.getInstance().get«actor.name»();
							role.execute();
						}
						break;
						«{i=i+1; null}»
						«ENDFOR»						
					}
				}
			}
		}			 
		'''
	}	
}
